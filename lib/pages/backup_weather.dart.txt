import 'dart:convert';
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:weather_icons/weather_icons.dart';

class WeatherData {
  final String cityName;
  final double temperature;
  final String description;
  final List<WeatherForecastData> forecastData;

  WeatherData({
    required this.cityName,
    required this.temperature,
    required this.description,
    required this.forecastData,
  });

  factory WeatherData.fromJson(
      Map<String, dynamic> json, List<WeatherForecastData> forecastData) {
    final List<dynamic> weather = json['weather'];
    final Map<String, dynamic> weatherData = weather[0];
    final Map<String, dynamic> main = json['main'];
    final double temperature = main['temp'];
    final String description = weatherData['description'];

    return WeatherData(
      cityName: json['name'],
      temperature: temperature,
      description: description,
      forecastData: forecastData,
    );
  }
}

class WeatherPage extends StatefulWidget {
  @override
  _WeatherPageState createState() => _WeatherPageState();
}

class _WeatherPageState extends State<WeatherPage> with AutomaticKeepAliveClientMixin<WeatherPage>{
  @override
  bool get wantKeepAlive => true;

  final _cityNameController = TextEditingController();
  WeatherData? _data;
  List<String> _favoriteCities = [];

  void _addFavoriteCity(String cityName) {
    setState(() {
      _favoriteCities.add(cityName);
      print(_favoriteCities);
    });
  }

  bool _isFavorite = false;

  void _toggleFavoriteCity(String cityName) {
    setState(() {
      if (!_isFavorite) {
        _favoriteCities.add(cityName);
        _isFavorite = true;
      } else {
        _favoriteCities.remove(cityName);
        _isFavorite = false;
        _data = null; // Rimuovi i dati della città dalla schermata
      }
      print(_favoriteCities);
    });
    if (!_favoriteCities.contains(cityName)) {
      _data = null; // Rimuovi i dati della città dalla schermata
    }
  }

  Future<void> _fetchWeatherData() async {
    final cityName = _cityNameController.text;
    final data = await getWeatherData(cityName);
    setState(() {
      _data = data;
    });
  }

  @override
  Widget build(BuildContext context) {
    super.build(context);
    return Scaffold(
      backgroundColor: Colors.purpleAccent,
      body: SingleChildScrollView(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: <Widget>[
            Padding(
              padding: const EdgeInsets.only(right: 16,left: 16,top: 16,bottom: 10),
              child: Container(
                decoration: BoxDecoration(
                  color: Colors.purpleAccent.shade400,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.pinkAccent,width: 3,),
                ),
                child: TextField(
                  controller: _cityNameController,
                  decoration: const InputDecoration(
                    border: InputBorder.none,
                    hintText: 'City Name',
                  ),
                  textAlign: TextAlign.center,
                ),
              ),
            ),
            Container(
              padding: const EdgeInsets.only(left: 16,right: 16),
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(16),
              ),
              child: ElevatedButton(
                onPressed: _fetchWeatherData,
                child: const Text('Vedi Previsioni'),
                style: ButtonStyle(
                  overlayColor: MaterialStateColor.resolveWith((states) => Colors.purpleAccent),
                ),
              ),
            ),
            if (_data != null)
              Column(
                children: [
                  Text(
                    _data!.cityName,
                    style: const TextStyle(fontSize: 32.0),
                  ),
                  Text(
                    '${_data!.temperature.toStringAsFixed(1)} °C',
                    style: const TextStyle(fontSize: 24.0),
                  ),
                  Text(
                    _data!.description,
                    style: const TextStyle(fontSize: 24.0),
                  ),
                  const SizedBox(height: 16),
                  for (final forecast in _data!.forecastData)
                    Padding(
                      padding: const EdgeInsets.fromLTRB(8, 2, 8, 2),
                      child: Container(
                        decoration: BoxDecoration(
                            color: Colors.deepPurpleAccent,
                            borderRadius: BorderRadius.circular(10),
                            border: Border.all(color: CupertinoColors.activeBlue,width: 2)
                        ),
                        child: ListTile(
                          leading: Icon(_getWeatherIcon(forecast.description)), // Aggiungi l'icona qui
                          title: Text(forecast.date),
                          subtitle: Text(forecast.description),
                          trailing: Text('${forecast.temperature.toStringAsFixed(1)} °C'),
                        ),
                      ),
                    ),
                ],
              ),
          ],
        ),
      ),
    );
  }
}

class WeatherForecastData {
  final String date;
  final double temperature;
  final String description;

  WeatherForecastData({
    required this.date,
    required this.temperature,
    required this.description,
  });

  factory WeatherForecastData.fromJson(Map<String, dynamic> json) {
    final List<dynamic> weather = json['weather'];
    final Map<String, dynamic> weatherData = weather[0];
    final Map<String, dynamic> main = json['main'];
    final double temperature = main['temp'];

    return WeatherForecastData(
      date: json['dt_txt'],
      temperature: temperature,
      description: weatherData['description'],
    );
  }
}

Future<WeatherData> getWeatherData(String cityName) async {
  const apiKey = 'db518e808bfe7200a4e13efd59891f54';
  final apiUrl = 'https://api.openweathermap.org/data/2.5/weather?q=$cityName&appid=$apiKey&units=metric';
  final forecastApiUrl =
      'https://api.openweathermap.org/data/2.5/forecast?q=$cityName&appid=$apiKey&units=metric&cnt=40';

  final weatherResponse = await http.get(Uri.parse(apiUrl));
  final forecastResponse = await http.get(Uri.parse(forecastApiUrl));

  if (weatherResponse.statusCode == 200 && forecastResponse.statusCode == 200) {
    final weatherJson = jsonDecode(weatherResponse.body);
    final forecastJson = jsonDecode(forecastResponse.body);
    final List<dynamic> forecastList = forecastJson['list'];
    final List<WeatherForecastData> forecastData = forecastList
        .map((forecast) => WeatherForecastData.fromJson(forecast))
        .toList();

    return WeatherData.fromJson(weatherJson, forecastData);
  } else {
    throw Exception('Failed to load weather data');
  }
}
IconData _getWeatherIcon(String description) {
  switch (description) {
    case 'clear sky':
      return Icons.wb_sunny;
    case 'overcast clouds':
      return Icons.cloud;
    case 'light rain':
      return Icons.grain;
    case 'Neve':
      return Icons.ac_unit;
    case 'heavy intensity rain':
      return Icons.flash_on;
    default:
      return Icons.error;
  }
}